/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ItemService_H
#define ItemService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "fuji.item_types.h"



#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ItemServiceIf {
 public:
  virtual ~ItemServiceIf() {}
  virtual void NewReleases(std::vector<Tops> & _return, const int64_t node_id) = 0;
  virtual void BestSellers(std::vector<Tops> & _return, const int64_t node_id) = 0;
  virtual void ReleaseDate(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page) = 0;
  virtual void SalesRanking(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page) = 0;
  virtual void ItemLookup(std::vector<Item> & _return, const std::string& item_id, const std::string& id_type) = 0;
  virtual void ItemList(std::vector<Item> & _return, const std::string& keyword, const int64_t page) = 0;
  virtual void NodeList(std::vector<Node> & _return, const int64_t node_id) = 0;
};

class ItemServiceIfFactory {
 public:
  typedef ItemServiceIf Handler;

  virtual ~ItemServiceIfFactory() {}

  virtual ItemServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ItemServiceIf* /* handler */) = 0;
};

class ItemServiceIfSingletonFactory : virtual public ItemServiceIfFactory {
 public:
  ItemServiceIfSingletonFactory(const boost::shared_ptr<ItemServiceIf>& iface) : iface_(iface) {}
  virtual ~ItemServiceIfSingletonFactory() {}

  virtual ItemServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ItemServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<ItemServiceIf> iface_;
};

class ItemServiceNull : virtual public ItemServiceIf {
 public:
  virtual ~ItemServiceNull() {}
  void NewReleases(std::vector<Tops> & /* _return */, const int64_t /* node_id */) {
    return;
  }
  void BestSellers(std::vector<Tops> & /* _return */, const int64_t /* node_id */) {
    return;
  }
  void ReleaseDate(std::vector<Item> & /* _return */, const int64_t /* node_id */, const std::string& /* category */, const int64_t /* page */) {
    return;
  }
  void SalesRanking(std::vector<Item> & /* _return */, const int64_t /* node_id */, const std::string& /* category */, const int64_t /* page */) {
    return;
  }
  void ItemLookup(std::vector<Item> & /* _return */, const std::string& /* item_id */, const std::string& /* id_type */) {
    return;
  }
  void ItemList(std::vector<Item> & /* _return */, const std::string& /* keyword */, const int64_t /* page */) {
    return;
  }
  void NodeList(std::vector<Node> & /* _return */, const int64_t /* node_id */) {
    return;
  }
};

typedef struct _ItemService_NewReleases_args__isset {
  _ItemService_NewReleases_args__isset() : node_id(false) {}
  bool node_id :1;
} _ItemService_NewReleases_args__isset;

class ItemService_NewReleases_args {
 public:

  ItemService_NewReleases_args(const ItemService_NewReleases_args&);
  ItemService_NewReleases_args& operator=(const ItemService_NewReleases_args&);
  ItemService_NewReleases_args() : node_id(0) {
  }

  virtual ~ItemService_NewReleases_args() throw();
  int64_t node_id;

  _ItemService_NewReleases_args__isset __isset;

  void __set_node_id(const int64_t val);

  bool operator == (const ItemService_NewReleases_args & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    return true;
  }
  bool operator != (const ItemService_NewReleases_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_NewReleases_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_NewReleases_pargs {
 public:


  virtual ~ItemService_NewReleases_pargs() throw();
  const int64_t* node_id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_NewReleases_result__isset {
  _ItemService_NewReleases_result__isset() : success(false) {}
  bool success :1;
} _ItemService_NewReleases_result__isset;

class ItemService_NewReleases_result {
 public:

  ItemService_NewReleases_result(const ItemService_NewReleases_result&);
  ItemService_NewReleases_result& operator=(const ItemService_NewReleases_result&);
  ItemService_NewReleases_result() {
  }

  virtual ~ItemService_NewReleases_result() throw();
  std::vector<Tops>  success;

  _ItemService_NewReleases_result__isset __isset;

  void __set_success(const std::vector<Tops> & val);

  bool operator == (const ItemService_NewReleases_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_NewReleases_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_NewReleases_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_NewReleases_presult__isset {
  _ItemService_NewReleases_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_NewReleases_presult__isset;

class ItemService_NewReleases_presult {
 public:


  virtual ~ItemService_NewReleases_presult() throw();
  std::vector<Tops> * success;

  _ItemService_NewReleases_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_BestSellers_args__isset {
  _ItemService_BestSellers_args__isset() : node_id(false) {}
  bool node_id :1;
} _ItemService_BestSellers_args__isset;

class ItemService_BestSellers_args {
 public:

  ItemService_BestSellers_args(const ItemService_BestSellers_args&);
  ItemService_BestSellers_args& operator=(const ItemService_BestSellers_args&);
  ItemService_BestSellers_args() : node_id(0) {
  }

  virtual ~ItemService_BestSellers_args() throw();
  int64_t node_id;

  _ItemService_BestSellers_args__isset __isset;

  void __set_node_id(const int64_t val);

  bool operator == (const ItemService_BestSellers_args & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    return true;
  }
  bool operator != (const ItemService_BestSellers_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_BestSellers_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_BestSellers_pargs {
 public:


  virtual ~ItemService_BestSellers_pargs() throw();
  const int64_t* node_id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_BestSellers_result__isset {
  _ItemService_BestSellers_result__isset() : success(false) {}
  bool success :1;
} _ItemService_BestSellers_result__isset;

class ItemService_BestSellers_result {
 public:

  ItemService_BestSellers_result(const ItemService_BestSellers_result&);
  ItemService_BestSellers_result& operator=(const ItemService_BestSellers_result&);
  ItemService_BestSellers_result() {
  }

  virtual ~ItemService_BestSellers_result() throw();
  std::vector<Tops>  success;

  _ItemService_BestSellers_result__isset __isset;

  void __set_success(const std::vector<Tops> & val);

  bool operator == (const ItemService_BestSellers_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_BestSellers_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_BestSellers_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_BestSellers_presult__isset {
  _ItemService_BestSellers_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_BestSellers_presult__isset;

class ItemService_BestSellers_presult {
 public:


  virtual ~ItemService_BestSellers_presult() throw();
  std::vector<Tops> * success;

  _ItemService_BestSellers_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_ReleaseDate_args__isset {
  _ItemService_ReleaseDate_args__isset() : node_id(false), category(false), page(false) {}
  bool node_id :1;
  bool category :1;
  bool page :1;
} _ItemService_ReleaseDate_args__isset;

class ItemService_ReleaseDate_args {
 public:

  ItemService_ReleaseDate_args(const ItemService_ReleaseDate_args&);
  ItemService_ReleaseDate_args& operator=(const ItemService_ReleaseDate_args&);
  ItemService_ReleaseDate_args() : node_id(0), category(), page(0) {
  }

  virtual ~ItemService_ReleaseDate_args() throw();
  int64_t node_id;
  std::string category;
  int64_t page;

  _ItemService_ReleaseDate_args__isset __isset;

  void __set_node_id(const int64_t val);

  void __set_category(const std::string& val);

  void __set_page(const int64_t val);

  bool operator == (const ItemService_ReleaseDate_args & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(category == rhs.category))
      return false;
    if (!(page == rhs.page))
      return false;
    return true;
  }
  bool operator != (const ItemService_ReleaseDate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ReleaseDate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_ReleaseDate_pargs {
 public:


  virtual ~ItemService_ReleaseDate_pargs() throw();
  const int64_t* node_id;
  const std::string* category;
  const int64_t* page;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ReleaseDate_result__isset {
  _ItemService_ReleaseDate_result__isset() : success(false) {}
  bool success :1;
} _ItemService_ReleaseDate_result__isset;

class ItemService_ReleaseDate_result {
 public:

  ItemService_ReleaseDate_result(const ItemService_ReleaseDate_result&);
  ItemService_ReleaseDate_result& operator=(const ItemService_ReleaseDate_result&);
  ItemService_ReleaseDate_result() {
  }

  virtual ~ItemService_ReleaseDate_result() throw();
  std::vector<Item>  success;

  _ItemService_ReleaseDate_result__isset __isset;

  void __set_success(const std::vector<Item> & val);

  bool operator == (const ItemService_ReleaseDate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_ReleaseDate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ReleaseDate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ReleaseDate_presult__isset {
  _ItemService_ReleaseDate_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_ReleaseDate_presult__isset;

class ItemService_ReleaseDate_presult {
 public:


  virtual ~ItemService_ReleaseDate_presult() throw();
  std::vector<Item> * success;

  _ItemService_ReleaseDate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_SalesRanking_args__isset {
  _ItemService_SalesRanking_args__isset() : node_id(false), category(false), page(false) {}
  bool node_id :1;
  bool category :1;
  bool page :1;
} _ItemService_SalesRanking_args__isset;

class ItemService_SalesRanking_args {
 public:

  ItemService_SalesRanking_args(const ItemService_SalesRanking_args&);
  ItemService_SalesRanking_args& operator=(const ItemService_SalesRanking_args&);
  ItemService_SalesRanking_args() : node_id(0), category(), page(0) {
  }

  virtual ~ItemService_SalesRanking_args() throw();
  int64_t node_id;
  std::string category;
  int64_t page;

  _ItemService_SalesRanking_args__isset __isset;

  void __set_node_id(const int64_t val);

  void __set_category(const std::string& val);

  void __set_page(const int64_t val);

  bool operator == (const ItemService_SalesRanking_args & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(category == rhs.category))
      return false;
    if (!(page == rhs.page))
      return false;
    return true;
  }
  bool operator != (const ItemService_SalesRanking_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_SalesRanking_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_SalesRanking_pargs {
 public:


  virtual ~ItemService_SalesRanking_pargs() throw();
  const int64_t* node_id;
  const std::string* category;
  const int64_t* page;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_SalesRanking_result__isset {
  _ItemService_SalesRanking_result__isset() : success(false) {}
  bool success :1;
} _ItemService_SalesRanking_result__isset;

class ItemService_SalesRanking_result {
 public:

  ItemService_SalesRanking_result(const ItemService_SalesRanking_result&);
  ItemService_SalesRanking_result& operator=(const ItemService_SalesRanking_result&);
  ItemService_SalesRanking_result() {
  }

  virtual ~ItemService_SalesRanking_result() throw();
  std::vector<Item>  success;

  _ItemService_SalesRanking_result__isset __isset;

  void __set_success(const std::vector<Item> & val);

  bool operator == (const ItemService_SalesRanking_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_SalesRanking_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_SalesRanking_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_SalesRanking_presult__isset {
  _ItemService_SalesRanking_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_SalesRanking_presult__isset;

class ItemService_SalesRanking_presult {
 public:


  virtual ~ItemService_SalesRanking_presult() throw();
  std::vector<Item> * success;

  _ItemService_SalesRanking_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_ItemLookup_args__isset {
  _ItemService_ItemLookup_args__isset() : item_id(false), id_type(false) {}
  bool item_id :1;
  bool id_type :1;
} _ItemService_ItemLookup_args__isset;

class ItemService_ItemLookup_args {
 public:

  ItemService_ItemLookup_args(const ItemService_ItemLookup_args&);
  ItemService_ItemLookup_args& operator=(const ItemService_ItemLookup_args&);
  ItemService_ItemLookup_args() : item_id(), id_type() {
  }

  virtual ~ItemService_ItemLookup_args() throw();
  std::string item_id;
  std::string id_type;

  _ItemService_ItemLookup_args__isset __isset;

  void __set_item_id(const std::string& val);

  void __set_id_type(const std::string& val);

  bool operator == (const ItemService_ItemLookup_args & rhs) const
  {
    if (!(item_id == rhs.item_id))
      return false;
    if (!(id_type == rhs.id_type))
      return false;
    return true;
  }
  bool operator != (const ItemService_ItemLookup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ItemLookup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_ItemLookup_pargs {
 public:


  virtual ~ItemService_ItemLookup_pargs() throw();
  const std::string* item_id;
  const std::string* id_type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ItemLookup_result__isset {
  _ItemService_ItemLookup_result__isset() : success(false) {}
  bool success :1;
} _ItemService_ItemLookup_result__isset;

class ItemService_ItemLookup_result {
 public:

  ItemService_ItemLookup_result(const ItemService_ItemLookup_result&);
  ItemService_ItemLookup_result& operator=(const ItemService_ItemLookup_result&);
  ItemService_ItemLookup_result() {
  }

  virtual ~ItemService_ItemLookup_result() throw();
  std::vector<Item>  success;

  _ItemService_ItemLookup_result__isset __isset;

  void __set_success(const std::vector<Item> & val);

  bool operator == (const ItemService_ItemLookup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_ItemLookup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ItemLookup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ItemLookup_presult__isset {
  _ItemService_ItemLookup_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_ItemLookup_presult__isset;

class ItemService_ItemLookup_presult {
 public:


  virtual ~ItemService_ItemLookup_presult() throw();
  std::vector<Item> * success;

  _ItemService_ItemLookup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_ItemList_args__isset {
  _ItemService_ItemList_args__isset() : keyword(false), page(false) {}
  bool keyword :1;
  bool page :1;
} _ItemService_ItemList_args__isset;

class ItemService_ItemList_args {
 public:

  ItemService_ItemList_args(const ItemService_ItemList_args&);
  ItemService_ItemList_args& operator=(const ItemService_ItemList_args&);
  ItemService_ItemList_args() : keyword(), page(0) {
  }

  virtual ~ItemService_ItemList_args() throw();
  std::string keyword;
  int64_t page;

  _ItemService_ItemList_args__isset __isset;

  void __set_keyword(const std::string& val);

  void __set_page(const int64_t val);

  bool operator == (const ItemService_ItemList_args & rhs) const
  {
    if (!(keyword == rhs.keyword))
      return false;
    if (!(page == rhs.page))
      return false;
    return true;
  }
  bool operator != (const ItemService_ItemList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ItemList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_ItemList_pargs {
 public:


  virtual ~ItemService_ItemList_pargs() throw();
  const std::string* keyword;
  const int64_t* page;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ItemList_result__isset {
  _ItemService_ItemList_result__isset() : success(false) {}
  bool success :1;
} _ItemService_ItemList_result__isset;

class ItemService_ItemList_result {
 public:

  ItemService_ItemList_result(const ItemService_ItemList_result&);
  ItemService_ItemList_result& operator=(const ItemService_ItemList_result&);
  ItemService_ItemList_result() {
  }

  virtual ~ItemService_ItemList_result() throw();
  std::vector<Item>  success;

  _ItemService_ItemList_result__isset __isset;

  void __set_success(const std::vector<Item> & val);

  bool operator == (const ItemService_ItemList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_ItemList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_ItemList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_ItemList_presult__isset {
  _ItemService_ItemList_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_ItemList_presult__isset;

class ItemService_ItemList_presult {
 public:


  virtual ~ItemService_ItemList_presult() throw();
  std::vector<Item> * success;

  _ItemService_ItemList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ItemService_NodeList_args__isset {
  _ItemService_NodeList_args__isset() : node_id(false) {}
  bool node_id :1;
} _ItemService_NodeList_args__isset;

class ItemService_NodeList_args {
 public:

  ItemService_NodeList_args(const ItemService_NodeList_args&);
  ItemService_NodeList_args& operator=(const ItemService_NodeList_args&);
  ItemService_NodeList_args() : node_id(0) {
  }

  virtual ~ItemService_NodeList_args() throw();
  int64_t node_id;

  _ItemService_NodeList_args__isset __isset;

  void __set_node_id(const int64_t val);

  bool operator == (const ItemService_NodeList_args & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    return true;
  }
  bool operator != (const ItemService_NodeList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_NodeList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ItemService_NodeList_pargs {
 public:


  virtual ~ItemService_NodeList_pargs() throw();
  const int64_t* node_id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_NodeList_result__isset {
  _ItemService_NodeList_result__isset() : success(false) {}
  bool success :1;
} _ItemService_NodeList_result__isset;

class ItemService_NodeList_result {
 public:

  ItemService_NodeList_result(const ItemService_NodeList_result&);
  ItemService_NodeList_result& operator=(const ItemService_NodeList_result&);
  ItemService_NodeList_result() {
  }

  virtual ~ItemService_NodeList_result() throw();
  std::vector<Node>  success;

  _ItemService_NodeList_result__isset __isset;

  void __set_success(const std::vector<Node> & val);

  bool operator == (const ItemService_NodeList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ItemService_NodeList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemService_NodeList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ItemService_NodeList_presult__isset {
  _ItemService_NodeList_presult__isset() : success(false) {}
  bool success :1;
} _ItemService_NodeList_presult__isset;

class ItemService_NodeList_presult {
 public:


  virtual ~ItemService_NodeList_presult() throw();
  std::vector<Node> * success;

  _ItemService_NodeList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ItemServiceClient : virtual public ItemServiceIf {
 public:
  ItemServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ItemServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void NewReleases(std::vector<Tops> & _return, const int64_t node_id);
  void send_NewReleases(const int64_t node_id);
  void recv_NewReleases(std::vector<Tops> & _return);
  void BestSellers(std::vector<Tops> & _return, const int64_t node_id);
  void send_BestSellers(const int64_t node_id);
  void recv_BestSellers(std::vector<Tops> & _return);
  void ReleaseDate(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page);
  void send_ReleaseDate(const int64_t node_id, const std::string& category, const int64_t page);
  void recv_ReleaseDate(std::vector<Item> & _return);
  void SalesRanking(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page);
  void send_SalesRanking(const int64_t node_id, const std::string& category, const int64_t page);
  void recv_SalesRanking(std::vector<Item> & _return);
  void ItemLookup(std::vector<Item> & _return, const std::string& item_id, const std::string& id_type);
  void send_ItemLookup(const std::string& item_id, const std::string& id_type);
  void recv_ItemLookup(std::vector<Item> & _return);
  void ItemList(std::vector<Item> & _return, const std::string& keyword, const int64_t page);
  void send_ItemList(const std::string& keyword, const int64_t page);
  void recv_ItemList(std::vector<Item> & _return);
  void NodeList(std::vector<Node> & _return, const int64_t node_id);
  void send_NodeList(const int64_t node_id);
  void recv_NodeList(std::vector<Node> & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ItemServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ItemServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ItemServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_NewReleases(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_BestSellers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReleaseDate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SalesRanking(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ItemLookup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ItemList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_NodeList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ItemServiceProcessor(boost::shared_ptr<ItemServiceIf> iface) :
    iface_(iface) {
    processMap_["NewReleases"] = &ItemServiceProcessor::process_NewReleases;
    processMap_["BestSellers"] = &ItemServiceProcessor::process_BestSellers;
    processMap_["ReleaseDate"] = &ItemServiceProcessor::process_ReleaseDate;
    processMap_["SalesRanking"] = &ItemServiceProcessor::process_SalesRanking;
    processMap_["ItemLookup"] = &ItemServiceProcessor::process_ItemLookup;
    processMap_["ItemList"] = &ItemServiceProcessor::process_ItemList;
    processMap_["NodeList"] = &ItemServiceProcessor::process_NodeList;
  }

  virtual ~ItemServiceProcessor() {}
};

class ItemServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ItemServiceProcessorFactory(const ::boost::shared_ptr< ItemServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ItemServiceIfFactory > handlerFactory_;
};

class ItemServiceMultiface : virtual public ItemServiceIf {
 public:
  ItemServiceMultiface(std::vector<boost::shared_ptr<ItemServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ItemServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ItemServiceIf> > ifaces_;
  ItemServiceMultiface() {}
  void add(boost::shared_ptr<ItemServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void NewReleases(std::vector<Tops> & _return, const int64_t node_id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->NewReleases(_return, node_id);
    }
    ifaces_[i]->NewReleases(_return, node_id);
    return;
  }

  void BestSellers(std::vector<Tops> & _return, const int64_t node_id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->BestSellers(_return, node_id);
    }
    ifaces_[i]->BestSellers(_return, node_id);
    return;
  }

  void ReleaseDate(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReleaseDate(_return, node_id, category, page);
    }
    ifaces_[i]->ReleaseDate(_return, node_id, category, page);
    return;
  }

  void SalesRanking(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SalesRanking(_return, node_id, category, page);
    }
    ifaces_[i]->SalesRanking(_return, node_id, category, page);
    return;
  }

  void ItemLookup(std::vector<Item> & _return, const std::string& item_id, const std::string& id_type) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ItemLookup(_return, item_id, id_type);
    }
    ifaces_[i]->ItemLookup(_return, item_id, id_type);
    return;
  }

  void ItemList(std::vector<Item> & _return, const std::string& keyword, const int64_t page) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ItemList(_return, keyword, page);
    }
    ifaces_[i]->ItemList(_return, keyword, page);
    return;
  }

  void NodeList(std::vector<Node> & _return, const int64_t node_id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->NodeList(_return, node_id);
    }
    ifaces_[i]->NodeList(_return, node_id);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ItemServiceConcurrentClient : virtual public ItemServiceIf {
 public:
  ItemServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ItemServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void NewReleases(std::vector<Tops> & _return, const int64_t node_id);
  int32_t send_NewReleases(const int64_t node_id);
  void recv_NewReleases(std::vector<Tops> & _return, const int32_t seqid);
  void BestSellers(std::vector<Tops> & _return, const int64_t node_id);
  int32_t send_BestSellers(const int64_t node_id);
  void recv_BestSellers(std::vector<Tops> & _return, const int32_t seqid);
  void ReleaseDate(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page);
  int32_t send_ReleaseDate(const int64_t node_id, const std::string& category, const int64_t page);
  void recv_ReleaseDate(std::vector<Item> & _return, const int32_t seqid);
  void SalesRanking(std::vector<Item> & _return, const int64_t node_id, const std::string& category, const int64_t page);
  int32_t send_SalesRanking(const int64_t node_id, const std::string& category, const int64_t page);
  void recv_SalesRanking(std::vector<Item> & _return, const int32_t seqid);
  void ItemLookup(std::vector<Item> & _return, const std::string& item_id, const std::string& id_type);
  int32_t send_ItemLookup(const std::string& item_id, const std::string& id_type);
  void recv_ItemLookup(std::vector<Item> & _return, const int32_t seqid);
  void ItemList(std::vector<Item> & _return, const std::string& keyword, const int64_t page);
  int32_t send_ItemList(const std::string& keyword, const int64_t page);
  void recv_ItemList(std::vector<Item> & _return, const int32_t seqid);
  void NodeList(std::vector<Node> & _return, const int64_t node_id);
  int32_t send_NodeList(const int64_t node_id);
  void recv_NodeList(std::vector<Node> & _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif



#endif
